<?xml version="1.0" encoding="UTF-8"?> 
<?xml-model href="../../../docbook-customization/src/docbkx-stylesheet/common/komet.rnc" type="application/relax-ng-compact-syntax"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">

    <title>Normalization</title>
    
    <informaltable>
        <tgroup cols="1">
            <colspec colnum="1" colname="col1"/>
            <tbody>
                <row>
                    <entry>
                        <para><emphasis role="bold">Purpose of this section:</emphasis></para>
                        <itemizedlist>
                            <listitem>
                                <para>Explain that the ANF Model is a normalized representation of a clinical statement, and other representations can be transformed into this one view</para>
                            </listitem>
                        </itemizedlist>
                    </entry>
                </row>
            </tbody>
        </tgroup>
    </informaltable>


    <para>
            Normalization of clinical statements is defined by Elkin as "the ability to identify
            every representational format that confers the same meaning as being equivalent (i.e.,
            unambiguous representation). 
    </para>


    <section>
        <title>Data Structures</title>
        <para>
            Currently, the standard is to define detailed clinical models using different data structures for 
            different domains of clinical statements.  For example, FHIR independently defines the resources for Conditions, 
            Observations, Diagnosis, Procedure, Goal, Medication Administration, Medication Request, etc. 
            Some implementations, such as FHIR, explicity define the property names
            for the parts of each data structure tree and other formalisms such as BMM/ADL and CEML 
            use a form of key-value pairing to genericise the property naming of the data structure tree. 
            But in all these cases, the fact remains that the resulting structure of the tree still remains different 
            for different domains of clinical statements. Thus, computation and analysis of data instances, that conform to these models, requires a 
            prior understanding of the tree structure for each domain.
        </para>
        <para>

        </para>
        <para>ANF seeks to simplify the complexity that currently exists in detailed clinical
            models.  As it's name suggests, Analysis Normal Form provides one normalized data structure to describe
            clinical statements from all domains.<footnote>
                <para>
                    This isn't entirely true. ANF actually describes different data structures for the Performance of an action versus the Request of an action.  
                </para>
            </footnote>
            ANF accomplishes this by moving the complexity that usually requires a complex data structure into
            the terminology as a complex post-coordinated snomed expression.
        </para>

    </section>

    <section>
        <title>Modeling Style</title>

        <para>
            Another variation that currently exists is the allowed design choices which can be made by model authors.
            For example, a modeler may choose to model breath sounds, as 'breath sounds' with a coded result of 'rales',
            or as 'rales' with a result of 'present'.
            Currently, organiztions try to minimize this type of variation by
            documenting design choice rules in modeling "style guides".
            For instance, a common style guide choice in the CIMI Clinical Statement model is to
            either use the Assertion style or the Evaluation Result style, and CIMI documents which types of clinical statement
            are best suited for each. The current approach is to solve the problem by conformity rather than with technology.
        </para>

        <para>
            ANF seeks to minimize this variation by only allowing quantitative results.  This eliminates the choice
            between Evaluation style versus Assertion style clinical statements as coded results are not possible.
        </para>

        

    </section>

    <section>
        <title>Transformation</title>

        <para>
            The previous sections have described the variation that can exist in the data structure and modeling style of a single standard.  Moreover, this variation is significantly compounded when simultaneously using data from multiple standards, such as when receiving data from mulitple institutions.
        </para>

        <para>
            Analysis Normal Form can act as a transformation target to normalize
            these disparate representaions of clinical statements, shown in <xref linkend="transformationToANF_0135" xrefstyle="select: label"/>.  Normalization implies the ability to recognize all representations that express the same meaning as being algorithimically equivalent.
        </para>

        <para>
            To be clear, the transformation discussed is a data instance to data instance transformation.  An example could be John Doe's Systolic Blood Pressure measurement taken on June 4, 2019 represented as a FHIR Observation instance, which is then transformed to an ANF instance representing this same data.  This is not to be confused with a detailed clinical model transformation between two formalisms, such as an ISO DCM for Systolic Blood Pressure transformed to a FHIR profile for Systolic Blood Pressure.
        </para>

        <figure xml:id="transformationToANF_0135">
            <title>Transformation to ANF</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/transformationToAnf.png" align="center" format="png" width="100%"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
           Transformation, in this case, is not a simple endeavor that one can hope to automate across domains of clinical statements or even within a single domain of clinical statements. As presented, it will involve navigating disparate data structure trees and include variable representations to then generate a well-formed post-coordinated snomed expression.  It is most likely possible to target subdomains for consistent transformation, such as all quantitative laboratory results, but in some cases, it may be that each detailed clinical model needs it's own unique transformation.
        </para>

        <para>
            Potential areas of difficulty during transformation
        </para>

            <itemizedlist spacing='compact'>
                <listitem>
                    <para>One source instance will frequently be transformed to many ANF instances</para>
                </listitem>
                <listitem>
                    <para>Implied clinical meaning of some data structure and bound terminology must be transformed into complex post-coordinated snomed expression for inclusion as ANF Topic</para>
                </listitem>
            </itemizedlist>


        <para>
            Currently, there are three basic categories of errors that
            might be associated with attempts at normalizing clinical statement represenation. The
            first is error associated with normalization of content of the terminology; the second
            is error associated with normalization of the semantics of the terminology; and, third
            is errors that result from ambiguous or misleading interaction between the structured
            clinical input and presentation of compound terminology to clinician end-users. 
        </para>

    </section>

        

    <!--
        <para>
            <itemizedlist>
                <listitem>
                    <para>reconcile data that is captured in a variety of mechanisms and making it
                        compatible with other data</para>
                </listitem>
                <listitem>
                    <para>moving clinical data to another system</para>
                </listitem>
                <listitem>
                    <para>joining it with other clinical data, or aggregate information in the
                        data</para>
                </listitem>
                <listitem>
                    <para>facilitate CDS and patient safety. </para>
                </listitem>
            </itemizedlist>
        </para>
    
        <para>
            Clinical data will start off overly post-coordinated but with the data potentially
            spread across multiple fields. By creating an ANF statement, one can take the disparate
            information and organize it so that the post-coordination is mostly contained in the
            topic representation instead of being spread across disparate fields. For instance,
            there may be 1 clinical statement in an EHR for blood pressure measurement and care
            planning that might be 5 observations when represented by FHIR. There are many different
            ways to create the FHIR data structures. Redundancy in representation of clinical
            statmenets may cause insertion, deletion and, maintenance of anomalies. 
        </para>



            <?oxy_comment_start author="jcoyle" timestamp="20190601T180110-0500" comment="I believe this is
            actually the opposite.  Normalization will result in the information being spread across more
            clinical statements.  For example, in ANF, patient sitting and having urinated will be there
            own associated clinical statements"?><?oxy_comment_end?>

            

        

        <para>
            
        </para>
            <?oxy_comment_start author="rcholan" timestamp="20190530T135125-0400" comment="We need exampes to walk through normalization. "?><?oxy_comment_end?>

        <para>
            With ANF, we aim to reduce the ambiguity and redundancy in model representation of
            clincial statements. ANF
            <?oxy_comment_start author="timowilliams" timestamp="20190522T215723-0500" comment="Where do concrete domains fit in?"?>will
            be able to handle concrete domains by increasing the payload in the topic representation
            and by putting all of the topic details in a post-coordinated SNOMED CT expression.
            <?oxy_comment_end?>By using the ANF model, with the increased specificity of the topic
            expression, the variability in representations is reduced since the CIMI Evaluation
            Result style representation of clinical data is eliminated..
            <?oxy_comment_start author="timowilliams" timestamp="20190522T220242-0500" comment="Is this true?  What about Status and Priority?  Even Presence and Absence can change the meaning of the topic."?>With
            ANF, the things that change meaning are always in the topic.<?oxy_comment_end?> Whether
            something is a request or has occurred – this is not in the topic. That separation is
            okay because of xxx.
        </para>

        <para>
            With ANF, we are cutting down the choices modelers will have to make, but we do not
            eliminate all the choices. There may still be more than 1 way to represent things in ANF
            and therefore there are the following editorial rules that we recommend to promote
            conformity amongst modelers: <?oxy_comment_start author="rcholan" timestamp="20190523T005636-0400" comment="Note from Keith: For the ANF document, we should somewhere describe assumptions about what an ANF implementation requires. For example, ANF requires an ability to classify topic expressions (and expressions that may go in other locations). Maybe a section that describes the requirements of a &quot;mapping&quot; based system with a plethora of statement models, and then what ANF requires above and beyond a mapping system, and what the benefits are. "?>xxx<?oxy_comment_end?>
            <?oxy_comment_start author="rcholan" timestamp="20190530T135833-0400" comment="Tim&apos;s decision tree?"?><?oxy_comment_end?>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20190523T103205-0500" comment="Should we discuss mapping issues here?  Can we reuse some of the Solor slides around mapping to highlight an issue of using mapping?"?>
            <para>The following diagram highlights how clinical statements recorded using a model of
                knowledge (e.g. CIMI model or archetype) are used to enter information that may be
                exchanged using a variety of interoperability artifacts (e.g. HL7 V2 messages, CDA
                documents, FHIR resources). If the information is aggregated and normalized for
                analysis, the ANF clinical statement may be used to extract/query normalized clinical
                statements using ANF-based FHIR template. The diagram illustrates the role each SAIF-CD
                Perspective. 
            </para><?oxy_comment_end?>
       
        <figure>
            <title>Applying ANF to analysis of aggregate clinical statements</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/transformation.svg" scalefit="1" width="100%"
                        format="SVG" contentdepth="50%"/>
                </imageobject>
            </mediaobject>
        </figure>
        
        <para>Normal forms are commonly used to eliminate or reduce redundancy in database tables.
            ANF can have similar benefits on clinical data storage and retrieval:</para>
        <para><emphasis role="bold">1. First Normal Form</emphasis></para>
        <para>If a relation contain composite or multi-valued attribute, it violates first normal
            form or a relation is in first normal form if it does not contain any composite or
            multi-valued attribute. A relation is in first normal form if every attribute in that
            relation is singled valued attribute.</para>
        <para><emphasis role="bold">2. Second Normal Form</emphasis></para>
        <para>To be in second normal form, a relation must be in first normal form and relation must
            not contain any partial dependency. A relation is in 2NF iff it has No Partial
            Dependency, i.e., no non-prime attribute (attributes which are not part of any candidate
            key) is dependent on any proper subset of any candidate key of the table.</para>
       </section>

    -->
    
    <section>
        <title>Transformation Languages</title>
        
        <para> A number of options exist for expressing transformation logic and for executing the
            transformation on specific instances of clinical data for normalization into ANF. This section discusses several transformation language options and the trade-offs among them. It should be noted that the suitability of the chosen language also highly depends on the format of the source data. 
        </para>

        <para>
            The first three of these, XSLT, FML, and QVT, are transformation languages that can be used directly, but the quality and accuracy of the transformation is left to the transformation author.  The last option described is MDMI, which is not a language, but an architecture for transformation.  This architecture assists in producing semantically accurate transformations.
        </para>

        <section>
            <title>XSLT</title>
            <para> XSLT is a W3C-standard language for the transformation of structured
                    data<footnote xml:id="__EN5__">
                    <para>
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="https://en.wikipedia.org/wiki/XSLT"
                            >https://en.wikipedia.org/wiki/XSLT </link> (Accessed 9/30/2017).
                    </para>
                </footnote>. XSLT transformation scripts take as input any valid XML document and
                produce as output an ASCII-formatted document (including XML, HTML, other formatting
                languages, free text, etc.). The XSLT language specifies transformations through
                declarative, rule-based commands (see below). </para>
            <para> XSLT is widely used in modern information processing, including in health care
                applications. Numerous XLST transformation engines exist, including commercial and
                open-source versions. These implementations are mature, stable, and
                high-performance, and are available as runtime libraries or embedded in XLST
                authoring/editing applications. Excellent documentation and training are available
                for XSLT. </para>
            <section>
                <title>Overview of Language and Data Model</title>
                <para> XSLT scripts operate over source “trees” containing the structured contents
                    of parsed XML documents. These trees contain as their nodes the various
                    constructs of specific XML documents, i.e., the named elements, attributes, and
                    text values that appear in the documents, and upon parsing, becomes a source
                    tree for XSLT transformations.</para>
                <para> XSLT uses the sub-language “XPath”<footnote xml:id="__EN6__">
                        <para>
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://en.wikipedia.org/wiki/XPath"
                                >https://en.wikipedia.org/wiki/XPath</link> (Accessed 9/30/2017).
                        </para>
                    </footnote> to reference portions of the XML source tree for purposes of
                    navigating the tree and selecting specific parts of it to translate. XPath is
                    essentially a query language for identifying and retrieving XML sub-trees that
                    match specified criteria. For example, the XPath query </para>
                <para> The actual transformation logic in XLST scripts is specified as a series of
                    “templates”. Each template matches to a specified sub-part of the source tree
                    and specifies what output will be generated for that sub-part. Template are
                    generally called from within other templates via a declarative template-matching
                    process, and a recursive traversal and transformation of the input tree occurs
                    through this template-invocation model. The transformation logic within
                    templates may include various conditional, branching, and formatting constructs,
                    as well as calls to external functions written in various programming languages
                    (such as Java). </para>
            </section>
            <section>
                <title>Advantages and Limitations</title>
                <para> XSLT is effective in representing and executing the transformation logic
                    needed for clinical translations. In general, XSLT provides various advantages,
                    as well as limitations, for this task. </para>
                <para><emphasis role="bold">Advantages</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>A powerful language</para>
                    </listitem>
                    <listitem>
                        <para>Declarative – automated matching of templates to data</para>
                    </listitem>
                    <listitem>
                        <para>Extensible via extension functions and external function calls</para>
                    </listitem>
                    <listitem>
                        <para>Many mature implementations</para>
                    </listitem>
                    <listitem>
                        <para>Good tooling (e.g., Eclipse plugin, XMLSpy)</para>
                    </listitem>
                    <listitem>
                        <para>Good documentation</para>
                    </listitem>
                </itemizedlist>
                <para><emphasis role="bold">Limitations</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Transformation specifications are verbose and hard to
                            read/understand/debug/maintain</para>
                    </listitem>
                    <listitem>
                        <para>Transformation are entirely syntactic</para>
                    </listitem>
                    <listitem>
                        <para>Limited to XML input – instances rendered in other formats cannot be
                            translated</para>
                    </listitem>
                </itemizedlist>
            </section>
        </section>

        <section>
            <title>FHIR Mapping Language</title>
            <para> The FHIR mapping language (FML) <footnote xml:id="__EN7__">
                    <para>
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="https://www.hl7.org/fhir/mapping-language.html"
                            >https://www.hl7.org/fhir/mapping-language.html</link> (Accessed
                        9/30/2017). </para>
                </footnote> is a relatively new, bespoke transformation language specifically
                designed to transform HL7 FHIR<footnote xml:id="__EN8__">
                    <para>
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="https://www.hl7.org/fhir/index.html"
                            >https://www.hl7.org/fhir/index.html</link> (Accessed 9/30/2017).
                    </para>
                </footnote> resources to alternative representations, including different FHIR
                resources, C/CDE documents, etc. The mapping language was created by Graham Grieve
                as a specification of the QVT framework for model-transformation languages (see
                Section <xref linkend="_Ref494462079"/>). </para>
            <section>
                <title>Overview of Language and Data Model</title>
                <para>Conceptually, FML is similar to XSLT in that it (a) consists of declarative
                    rules that are automatically matched to input data, (b) includes a sub-language
                    (“FHIRPath”) to reference parts of source parse trees, and (c) has the ability
                    to reference external functions written in different languages. There are also
                    notable differences between FML and XSLT.
                    The source input of FML is not limited to XML documents, but may include
                    any object models and rendering syntaxes conformant with OMG’s Meta Object
                    Facility (MOF) language<footnote xml:id="__EN9__">
                        <para>
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.omg.org/mof/">http://www.omg.org/mof/</link>
                            (Accessed 9/30/2017). </para>
                    </footnote>. MOF is a general formalism for representing object models as
                    directed acyclic graphs (DAGs), and MOF-compliant models can use various
                    syntactic constructs to represent the classes, attributes, and attribute values
                    of such graphs. </para>
                <para> Hence, in FML, there is no built-in notion of source trees containing XML
                    “elements”, “attributes”, “comments”, “namespaces”, etc. In fact, FML
                    transformation rules do not specify any target syntax for inputs or outputs,
                    just the general concepts of named classes, class members, and member values.
                    This flexibility would allow transformation source inputs used in the normalization to ANF
                    to be represented in different formats than XML, were that
                    to be deemed preferable. For example, instances rendered using JSON,
                        ODIN<footnote xml:id="__EN10__">
                        <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.openehr.org/releases/BASE/latest/docs/odin/odin.html"
                                >http://www.openehr.org/releases/BASE/latest/docs/odin/odin.html</link>
                            (Accessed 9/30/2017). </para>
                    </footnote>, or ASN1 syntax could be the inputs of FML transformations. </para>
                <para> The output of an FML transformation is not a text-rendered document (unlike
                    XSLT), but an internally stored DAG consistent with the specified output model.
                    Subsequently, the DAG may be rendered in any number of syntaxes, including XML,
                    JSON, or the tables and fields of a relational database. </para>
            </section>
            <section>
                <title>Advantages and Limitations</title>
                <para>The FHIR Mapping Language may also be effective in representing and executing
                    the transformation logic needed
                    for normalization to ANF. As with XSLT, however, there
                    exist certain trade-offs in its use.
                </para>
                <para><emphasis role="bold">Advantages</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Support for input formats other than XML</para>
                    </listitem>
                    <listitem>
                        <para>Transformation logic produces semantic DAGs, which can be subsequently
                            rendered in a variety of syntaxes.</para>
                    </listitem>
                    <listitem>
                        <para>The mapping specifications are more concise and easy to
                            read/understand than XLST</para>
                    </listitem>
                </itemizedlist>
                <para><emphasis role="bold">Limitations</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Inputs/outputs other than FHIR logical models currently require
                            additional custom programming</para>
                    </listitem>
                    <listitem>
                        <para>Only XML and JSON are currently supported as output syntaxes without
                            custom programming</para>
                    </listitem>
                    <listitem>
                        <para>Only one implementation to date (as a library)</para>
                    </listitem>
                    <listitem>
                        <para>Limited tools for authoring/editing transformation scripts</para>
                    </listitem>
                    <listitem>
                        <para>Limited sources of documentation</para>
                    </listitem>
                    <listitem>
                        <para>Few knowledgeable programmers</para>
                    </listitem>
                </itemizedlist>
            </section>
        </section>

        <section xml:id="_Ref494462079">
            <title>QVT</title>
            <para> A third alternative is to develop a new transformation language customized to
                support the requirements of a normalization to ANF, 
                based on the QVT language used to develop the FHIR Mapping Language. </para>
            <section>
                <title>Overview</title>
                <para>QVT<footnote xml:id="__EN11__">
                        <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.omg.org/spec/QVT/1.2/PDF/"
                                >http://www.omg.org/spec/QVT/1.2/PDF/</link> (Accessed 9/30/2017).
                        </para>
                    </footnote> is a general model-transformation framework and language developed
                    by the Object Management Group . It includes both an imperative (“QVT-O”) and a
                    declarative (“QVT-R”) version, and offers considerable flexibility in defining
                    the constructs of purpose-specific transformation languages. Although QVT is
                    intended for the transformation of data <emphasis>models</emphasis> rather than
                    data instances, the FHIR Mapping Language shows that it can be applied to the
                    latter task as well. </para>
                <para> A number of implementations of QVT exist as open-source and commercial
                    software offerings. These include: </para>
                <itemizedlist>
                    <listitem>
                        <para>ATL (open source). Probably the most widely used and maintained of the
                            available implementations. Includes a library of existing QVT
                            transformations, to serve as examples and templates. </para>
                    </listitem>
                    <listitem>
                        <para>Eclipse M2M Project (open source). An Eclipse project that includes
                            authoring tools for QVT transformations, as well as various
                            transformation engines (including the one from ATL). </para>
                    </listitem>
                    <listitem>
                        <para>ModelMorf (proprietary)</para>
                    </listitem>
                    <listitem>
                        <para>Others (see <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://en.wikipedia.org/wiki/QVT"
                                >https://en.wikipedia.org/wiki/QVT</link>) </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Advantages and Limitations</title>
                <para> The strength of QVT is that it is very abstract, which confers great
                    flexibility and configurability to create custom transformation languages.
                    However, the abstractness also makes QVT quite difficult to understand and
                    learn, and there are limited resources to assist in the learning process. For
                    example, a search on Amazon Books for references on the QVT framework yielded
                    only 8 relevant results, most of which were not in English. In contrast, a
                    similar search for XSLT references returned 270 results. </para>
            </section>
        </section>

        <section>
            <!-- MDMI  -->

            <title>Model Driven Message Interoperability (MDMI)</title>

            <para>
                MDMI is an Object Management Group Standard for the transformation of data in one format to data in another format. MDMI Standard is not a language. The MDMI Standard is a specification for addressing this problem and was developed by multiple domain experts. The specification contains two major sections; the MDMI Transformation Metamodel and the MDMI Semantic Element Exchange Repository (SEER). 
            </para>

            <figure xml:id="transformation_mdmi_standard_0135">
                <title>MDMI Standard</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mdmi_standard.png" align="center" format="png" width="100%"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The MDMI Transformation Metamodel is composed of a syntax model and a semantic model. The syntax model contains the syntactical representation of each data element in a format and the semantic model contains the semantic concept represented by the data element. The syntax model is used to compose a collection of semantic representations into a target file format or to decompose a source file into its semantic representations.  The syntax model can be used for any format.  XML, JSON, HL7 V.2, CVS, various EDI payment, and proprietary formats have been used.
            </para>

            <para>
                The semantic model captures the semantic concepts in the format and the relationships between the semantic concepts in a format. Probably the most important relationship is the containership relationships. The semantic model of the MDMI is also used to capture other relationships and rules required to create unambiguous semantic representations. An example of this is a data element that can have multiple semantics concepts that must be disambiguated based on other values contained in format.  
            </para>

            <para>
                The MDMI SEER is a repository for the semantically unique concepts, called Business Elements, that are exchanged in healthcare transformations. One can view the MDMI SEER as a bag of unique, atomic semantic concepts exchanged primarily driven by the HL7 standards of v.2, CDA, and FHIR that are used to exchange information.  If there is a new semantic concept that does not exist in the SEER, then a new Business Element is simply added. Each MDMI Transformation Model uses the MDMI SEER to create an iso-semantic relationship with its own semantic concepts and a Business Element.    
            </para>

            <figure xml:id="transformation_mdmi_process_0135">
                <title>MDMI Transformation Process</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/mdmi_transformation_process.png" align="center" format="png" width="100%"/>
                    </imageobject>
                </mediaobject>
            </figure>


            <para>
                There is a project underway in the OMG to extend the MDMI SEER. The Business Elements in the MDMI SEER are pre-coordinated semantic concepts represented in industry standard healthcare ontologies and terminologies. The project is using the ANF Clinical Statement Model as a Reference Model to develop a semantic model that can precisely define the meaning of the Business Element in a detailed, structured, unambiguous, computable formalism. 
            </para>

            <para>
                An open source implementation of MDMI started in the Open Healthcare Tools organization which built an MDMI compliant tooling for healthcare. The MDMI Open Source Project continues today in GITHUB and has been and is being used in HL7 projects as well as in commercial implementations.
            </para>


        </section>

        <section>
            <title>Advantages and Limitations</title>

            <para> MDMI is a model driven approach. Having a formal model, the open source project
                has been able to develop tooling based on the MDMI model as well as leverage other
                modeling efforts. Examples are Information Models such as FHIR and the FHIM using
                the model driven MDHT tooling and Ontological Models such as ANF / Solor. </para>

            <para><emphasis role="bold">Advantages</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Any to Any transformations versus point to point language mappings allow reuse of transformation models for different use cases.</para>
                    </listitem>
                    <listitem>
                        <para>It minimizes change. If one MDMI Model changes (e.g. FHIR 4 to FHIR 5), this does not require changes to other existing MDMI Models such as CCDA 2.1, HL7 V2.8, or a proprietary model.</para>
                    </listitem>
                    <listitem>
                        <para>It simplifies development.  Tooling exists to develop and maintain individual MDMI Models by SMEs who do not need to be developers. The scope of expertise is further reduced because the knowledge one needs to create a MDMI Model is primary to know what the data in their format means. </para>
                    </listitem>
                    <listitem>
                        <para>It enables automation tooling for creating MDMI models, for creating computable artifacts, and generating reports.</para>
                    </listitem>
                    <listitem>
                        <para>There are Open Source Models for HL7 formats as well as the MDMI tooling.</para>
                    </listitem>
                </itemizedlist>
                <para><emphasis role="bold">Limitations</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>MDMI has limited experience with transformations of detailed clinical models.</para>
                    </listitem>
                    <listitem>
                        <para>User Documentation of MDMI is lacking.</para>
                    </listitem>
                    <listitem>
                        <para>The MDMI runtime tool is complex.</para>
                    </listitem>
                    
                </itemizedlist>

        </section>

    </section>
</chapter>
