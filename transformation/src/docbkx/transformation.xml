<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbookxi.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/sch/docbook.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <title><?oxy_comment_start author="kmaulden" timestamp="20190423T101734-0400" comment="KC: Don’t put too much effort into this. Describe transformation on a high level. Put the most work into the examples (BP, Pulse etc. earlier in the document)
IS: Big value is the endpoint of data being normalized into ANF. 
KC: We can convince people that ANF has value like 1st normal form and 2nd normal form (Tim has expertise here). 
"?>Normalization<?oxy_comment_end?>
    </title>
    <?oxy_comment_start author="rcholan" timestamp="20190530T135236-0400" comment="Perhaps we should change this chapter name to Normalization..."?>
    <informaltable><?oxy_comment_end?>
        <tgroup cols="1">
            <colspec colnum="1" colname="col1"/>
            <tbody>
                <row>
                    <entry>
                        <para><emphasis role="bold">Purpose of this section:</emphasis></para>
                        <itemizedlist>
                            <listitem>
                                <para>Explain that the ANF Model is a normalized representation of a clinical statement, and other representations can be transformed into this one view</para>
                            </listitem>
                        </itemizedlist>
                    </entry>
                </row>
            </tbody>
        </tgroup>
    </informaltable>


    <para>
            Normalization of clinical statements is defined by Elkin as "the ability to identify
            every representational format that confers the same meaning as being equivalent (i.e.,
            unambiguous representation). 
    </para>


    <section>
        <title>Data Structures</title>
        <para>
            Currently, the standard is to define detailed clinical models using different data structures for 
            different domains of clinical statements.  For example, FHIR independently defines the resources for Conditions, 
            Observations, Diagnosis, Procedure, Goal, Medication Administration, Medication Request, etc. 
            Some implementations, such as FHIR, explicity define the property names
            for the parts of each data structure tree and other formalisms such as BMM/ADL and CEML 
            use a form of key-value pairing to genericise the property naming of the data structure tree. 
            But in all these cases, the fact remains that the resulting structure of the tree still remains different 
            for different domains of clinical statements. Thus, computation and analysis requires a 
            prior understanding of the tree structure for each domain.
        </para>
        <para>

        </para>
        <para>ANF seeks to simplify the complexity that currently exists in detailed clinical
            models.  As it's name suggests, Analysis Normal Form provides one normalized data structure to describe
            clinical statements from all domains.<footnote>
                <para>
                    This isn't entirely true. ANF actually describes different data structures for the Performance of an action versus the Request of an action.  
                </para>
            </footnote>
            ANF accomplishes this by moving the complexity that usually requires a complex data structure into
            the terminology as a complex post-coordinated snomed expression.
        </para>

    </section>

    <section>
        <title>Modeling Choices</title>

        <para>
            Another variation that currently exists are the allowed design choices which can be made by model authors.
            For example, a modeler may choose to model breath sounds, as 'breath sounds' with a coded result of 'rales',
            or as 'rales' with a result of 'present'.
            Currently, organiztions try to minimize this type of variation by
            documenting design choice rules in modeling "style guides".
            For instance, a common style guide choice in the CIMI Clinical Statement model is to
            either use the Assertion style or the Evaluation Result style, and CIMI documents which types of clinical statement
            are best suited for each. The current approach is to solve the problem by conformity rather than with technology.
        </para>

        <para>
            ANF seeks to minimize this variation by only allowing quantitative results.  This eliminates the choice
            between Evaluation style versus Assertion style clinical statements as coded results are not possible.
        </para>

    </section>

    <section>
        <title>Transformation</title>

        <para>
            We have described current systems as having variation in data structure and modeling style.  This variation is further compounded
            when When transferring data between and amongst institutions. Analysis Normal Form can act as a transformation target to normalize
            these disparate representaions of clinical statements, shown in <xref linkend="transformationToANF_0135"/>.  Normalization implies the ability to recognize all representations that express the same meaning as being algorithimically equivalent.
        </para>

        <figure xml:id="transformationToANF_0135">
            <title>Transformation to ANF</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/transformationToAnf.png" align="center" format="png" width="100%"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
           Transformation, in this case, is not a simple endeavor that one can hope to automate across domains of clinical statements or even within a single domain of clinical statements. As presented, it will involve navigating disparate data structure trees and include variable representations to then generate a well-formed post-coordinated snomed expression.  It is most likely possible to target subdomains for consistent transformation, such as all quantitative laboratory results, but in some cases, it may be that one detailed clinical model needs it's own unique transformation.
        </para>

        <para>
            Currently, there are three basic categories of errors that
            might be associated with attempts at normalizing clinical statement represenation. The
            first is error associated with normalization of content of the terminology; the second
            is error associated with normalization of the semantics of the terminology; and, third
            is errors that result from ambiguous or misleading interaction between the structured
            clinical input and presentation of compound terminology to clinician end-users. 
        </para>

        

    <!--
        <para>
            <itemizedlist>
                <listitem>
                    <para>reconcile data that is captured in a variety of mechanisms and making it
                        compatible with other data</para>
                </listitem>
                <listitem>
                    <para>moving clinical data to another system</para>
                </listitem>
                <listitem>
                    <para>joining it with other clinical data, or aggregate information in the
                        data</para>
                </listitem>
                <listitem>
                    <para>facilitate CDS and patient safety. </para>
                </listitem>
            </itemizedlist>
        </para>
    
        <para>
            Clinical data will start off overly post-coordinated but with the data potentially
            spread across multiple fields. By creating an ANF statement, one can take the disparate
            information and organize it so that the post-coordination is mostly contained in the
            topic representation instead of being spread across disparate fields. For instance,
            there may be 1 clinical statement in an EHR for blood pressure measurement and care
            planning that might be 5 observations when represented by FHIR. There are many different
            ways to create the FHIR data structures. Redundancy in representation of clinical
            statmenets may cause insertion, deletion and, maintenance of anomalies. 
        </para>



            <?oxy_comment_start author="jcoyle" timestamp="20190601T180110-0500" comment="I believe this is
            actually the opposite.  Normalization will result in the information being spread across more
            clinical statements.  For example, in ANF, patient sitting and having urinated will be there
            own associated clinical statements"?><?oxy_comment_end?>

            

        

        <para>
            
        </para>
            <?oxy_comment_start author="rcholan" timestamp="20190530T135125-0400" comment="We need exampes to walk through normalization. "?><?oxy_comment_end?>

        <para>
            With ANF, we aim to reduce the ambiguity and redundancy in model representation of
            clincial statements. ANF
            <?oxy_comment_start author="timowilliams" timestamp="20190522T215723-0500" comment="Where do concrete domains fit in?"?>will
            be able to handle concrete domains by increasing the payload in the topic representation
            and by putting all of the topic details in a post-coordinated SNOMED CT expression.
            <?oxy_comment_end?>By using the ANF model, with the increased specificity of the topic
            expression, the variability in representations is reduced since the CIMI Evaluation
            Result style representation of clinical data is eliminated..
            <?oxy_comment_start author="timowilliams" timestamp="20190522T220242-0500" comment="Is this true?  What about Status and Priority?  Even Presence and Absence can change the meaning of the topic."?>With
            ANF, the things that change meaning are always in the topic.<?oxy_comment_end?> Whether
            something is a request or has occurred – this is not in the topic. That separation is
            okay because of xxx.
        </para>

        <para>
            With ANF, we are cutting down the choices modelers will have to make, but we do not
            eliminate all the choices. There may still be more than 1 way to represent things in ANF
            and therefore there are the following editorial rules that we recommend to promote
            conformity amongst modelers: <?oxy_comment_start author="rcholan" timestamp="20190523T005636-0400" comment="Note from Keith: For the ANF document, we should somewhere describe assumptions about what an ANF implementation requires. For example, ANF requires an ability to classify topic expressions (and expressions that may go in other locations). Maybe a section that describes the requirements of a &quot;mapping&quot; based system with a plethora of statement models, and then what ANF requires above and beyond a mapping system, and what the benefits are. "?>xxx<?oxy_comment_end?>
            <?oxy_comment_start author="rcholan" timestamp="20190530T135833-0400" comment="Tim&apos;s decision tree?"?><?oxy_comment_end?>
        </para>
        <?oxy_comment_start author="timowilliams" timestamp="20190523T103205-0500" comment="Should we discuss mapping issues here?  Can we reuse some of the Solor slides around mapping to highlight an issue of using mapping?"?>
            <para>The following diagram highlights how clinical statements recorded using a model of
                knowledge (e.g. CIMI model or archetype) are used to enter information that may be
                exchanged using a variety of interoperability artifacts (e.g. HL7 V2 messages, CDA
                documents, FHIR resources). If the information is aggregated and normalized for
                analysis, the ANF clinical statement may be used to extract/query normalized clinical
                statements using ANF-based FHIR template. The diagram illustrates the role each SAIF-CD
                Perspective. 
            </para><?oxy_comment_end?>
       
        <figure>
            <title>Applying ANF to analysis of aggregate clinical statements</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/transformation.svg" scalefit="1" width="100%"
                        format="SVG" contentdepth="50%"/>
                </imageobject>
            </mediaobject>
        </figure>
        
        <para>Normal forms are commonly used to eliminate or reduce redundancy in database tables.
            ANF can have similar benefits on clinical data storage and retrieval:</para>
        <para><emphasis role="bold">1. First Normal Form</emphasis></para>
        <para>If a relation contain composite or multi-valued attribute, it violates first normal
            form or a relation is in first normal form if it does not contain any composite or
            multi-valued attribute. A relation is in first normal form if every attribute in that
            relation is singled valued attribute.</para>
        <para><emphasis role="bold">2. Second Normal Form</emphasis></para>
        <para>To be in second normal form, a relation must be in first normal form and relation must
            not contain any partial dependency. A relation is in 2NF iff it has No Partial
            Dependency, i.e., no non-prime attribute (attributes which are not part of any candidate
            key) is dependent on any proper subset of any candidate key of the table.</para>
    </section>

    -->
    </section>
    <section>
        <title>Transformation Languages</title>
        <?oxy_comment_start author="jcoyle" timestamp="20190601T180110-0500" comment="This section was
        taken and edited from Walter Sujansky&apos;s Transformation Languages white paper"?><?oxy_comment_end?>
        <para> A number of options exist for expressing transformation logic and for executing the
            transformation on specific instances of clinical data. This section discusses several of
            these options and the trade-offs among them. </para>
        <?oxy_comment_start author="Ioana" timestamp="20190610T232839-0400" comment="Please validate this..."?>
        <para>Depending on format of the data sources, one of more of the following transformation
            may be suitable for normalizing ad-hoc clinical statements to
            ANF:<?oxy_comment_end?></para>
        <section>
            <title>XSLT</title>
            <para> XSLT is a W3C-standard language for the transformation of structured
                    data<footnote xml:id="__EN5__">
                    <para>
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="https://en.wikipedia.org/wiki/XSLT"
                            >https://en.wikipedia.org/wiki/XSLT </link> (Accessed 9/30/2017).
                    </para>
                </footnote>. XSLT transformation scripts take as input any valid XML document and
                produce as output an ASCII-formatted document (including XML, HTML, other formatting
                languages, free text, etc.). The XSLT language specifies transformations through
                declarative, rule-based commands (see below). </para>
            <para> XSLT is widely used in modern information processing, including in health care
                applications. Numerous XLST transformation engines exist, including commercial and
                open-source versions. These implementations are mature, stable, and
                high-performance, and are available as runtime libraries or embedded in XLST
                authoring/editing applications. Excellent documentation and training are available
                for XSLT. </para>
            <section>
                <title>Overview of Language and Data Model</title>
                <para> XSLT scripts operate over source “trees” containing the structured contents
                    of parsed XML documents. These trees contain as their nodes the various
                    constructs of specific XML documents, i.e., the named elements, attributes, and
                    text values that appear in the documents, and upon parsing, becomes a source
                    tree for XSLT transformations.</para>
                <para> XSLT uses the sub-language “XPath”<footnote xml:id="__EN6__">
                        <para>
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://en.wikipedia.org/wiki/XPath"
                                >https://en.wikipedia.org/wiki/XPath</link> (Accessed 9/30/2017).
                        </para>
                    </footnote> to reference portions of the XML source tree for purposes of
                    navigating the tree and selecting specific parts of it to translate. XPath is
                    essentially a query language for identifying and retrieving XML sub-trees that
                    match specified criteria. For example, the XPath query </para>
                <para> The actual transformation logic in XLST scripts is specified as a series of
                    “templates”. Each template matches to a specified sub-part of the source tree
                    and specifies what output will be generated for that sub-part. Template are
                    generally called from within other templates via a declarative template-matching
                    process, and a recursive traversal and transformation of the input tree occurs
                    through this template-invocation model. The transformation logic within
                    templates may include various conditional, branching, and formatting constructs,
                    as well as calls to external functions written in various programming languages
                    (such as Java). </para>
            </section>
            <section>
                <title>Advantages and Limitations</title>
                <para> XSLT is effective in representing and executing the transformation logic
                    needed for clinical translations. In general, XSLT provides various advantages,
                    as well as limitations, for this task. </para>
                <para><emphasis role="bold">Advantages</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>A powerful language</para>
                    </listitem>
                    <listitem>
                        <para>Declarative – automated matching of templates to data</para>
                    </listitem>
                    <listitem>
                        <para>Extensible via extension functions and external function calls</para>
                    </listitem>
                    <listitem>
                        <para>Many mature implementations</para>
                    </listitem>
                    <listitem>
                        <para>Good tooling (e.g., Eclipse plugin, XMLSpy)</para>
                    </listitem>
                    <listitem>
                        <para>Good documentation</para>
                    </listitem>
                </itemizedlist>
                <para><emphasis role="bold">Limitations</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Transformation specifications are verbose and hard to
                            read/understand/debug/maintain</para>
                    </listitem>
                    <listitem>
                        <para>Transformation are entirely syntactic</para>
                    </listitem>
                    <listitem>
                        <para>Limited to XML input – instances rendered in other formats cannot be
                            translated</para>
                    </listitem>
                </itemizedlist>
            </section>
        </section>
        <section>
            <title>FHIR Mapping Language</title>
            <para> The FHIR mapping language (FML) <footnote xml:id="__EN7__">
                    <para>
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="https://www.hl7.org/fhir/mapping-language.html"
                            >https://www.hl7.org/fhir/mapping-language.html</link> (Accessed
                        9/30/2017). </para>
                </footnote> is a relatively new, bespoke transformation language specifically
                designed to transform HL7 FHIR<footnote xml:id="__EN8__">
                    <para>
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="https://www.hl7.org/fhir/index.html"
                            >https://www.hl7.org/fhir/index.html</link> (Accessed 9/30/2017).
                    </para>
                </footnote> resources to alternative representations, including different FHIR
                resources, C/CDE documents, etc. The mapping language was created by Graham Grieve
                as a specification of the QVT framework for model-transformation languages (see
                Section <xref linkend="_Ref494462079"/>). </para>
            <section>
                <title>Overview of Language and Data Model</title>
                <para>Conceptually, FML is similar to XSLT in that it (a) consists of declarative
                    rules that are automatically matched to input data, (b) includes a sub-language
                    (“FHIRPath”) to reference parts of source parse trees, and (c) has the ability
                    to reference external functions written in different languages. There are also
                    notable differences between FML and XSLT.
                    <?oxy_comment_start author="Ioana" timestamp="20190610T232708-0400" comment="XML-encoded FHIR resources are XML documents - instances of XML Document Object Model (DOM)  https://www.w3.org/DOM/"?>FHIR
                    inputs are not constrained to XML documents,<?oxy_comment_end?> but may include
                    any object models and rendering syntaxes conformant with OMG’s Meta Object
                    Facility (MOF) language<footnote xml:id="__EN9__">
                        <para>
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.omg.org/mof/">http://www.omg.org/mof/</link>
                            (Accessed 9/30/2017). </para>
                    </footnote>. MOF is a general formalism for representing object models as
                    directed acyclic graphs (DAGs), and MOF-compliant models can use various
                    syntactic constructs to represent the classes, attributes, and attribute values
                    of such graphs. </para>
                <para> Hence, in FML, there is no built-in notion of source trees containing XML
                    “elements”, “attributes”, “comments”, “namespaces”, etc. In fact, FML
                    transformation rules do not specify any target syntax for inputs or outputs,
                    just the general concepts of named classes, class members, and member values.
                    This flexibility would allow
                    <?oxy_comment_start author="Ioana" timestamp="20190610T232213-0400" comment="Should this say &quot;normalization to ANF&quot;?"?>CIMI-to-SOLOR<?oxy_comment_end?>
                    transformation inputs to be represented in different formats than XML, were that
                    to be deemed preferable. For example, instances rendered using JSON,
                        ODIN<footnote xml:id="__EN10__">
                        <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.openehr.org/releases/BASE/latest/docs/odin/odin.html"
                                >http://www.openehr.org/releases/BASE/latest/docs/odin/odin.html</link>
                            (Accessed 9/30/2017). </para>
                    </footnote>, or ASN1 syntax could be the inputs of FML transformations. </para>
                <para> The output of an FML transformation is not a text-rendered document (unlike
                    XSLT), but an internally stored DAG consistent with the specified output model.
                    Subsequently, the DAG may be rendered in any number of syntaxes, including XML,
                    JSON, or the tables and fields of a relational database. </para>
            </section>
            <section>
                <title>Advantages and Limitations</title>
                <para>The FHIR Mapping Language may also be effective in representing and executing
                    the transformation logic
                    needed<?oxy_comment_start author="Ioana" timestamp="20190610T160258-0400" comment="Should this section refer to &quot;source information to ANF&quot;?"?>
                    for CIMI-to-SOLOR translations<?oxy_comment_end?>. As with XSLT, however, there
                    exist certain trade-offs in its use. </para>
                <para><emphasis role="bold">Advantages</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Support for input formats other than XML</para>
                    </listitem>
                    <listitem>
                        <para>Transformation logic produces semantic DAGs, which can be subsequently
                            rendered in a variety of syntaxes.</para>
                    </listitem>
                    <listitem>
                        <para>The mapping specifications are more concise and easy to
                            read/understand than XLST</para>
                    </listitem>
                </itemizedlist>
                <para><emphasis role="bold">Limitations</emphasis></para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Inputs/outputs other than FHIR logical models currently require
                            additional custom programming</para>
                    </listitem>
                    <listitem>
                        <para>Only XML and JSON are currently supported as output syntaxes without
                            custom programming</para>
                    </listitem>
                    <listitem>
                        <para>Only one implementation to date (as a library)</para>
                    </listitem>
                    <listitem>
                        <para>Limited tools for authoring/editing transformation scripts</para>
                    </listitem>
                    <listitem>
                        <para>Limited sources of documentation</para>
                    </listitem>
                    <listitem>
                        <para>Few knowledgeable programmers</para>
                    </listitem>
                </itemizedlist>
            </section>
        </section>
        <section xml:id="_Ref494462079">
            <title>QVT</title>
            <para> A third alternative is to develop a new transformation language customized to
                support the requirements of
                <?oxy_comment_start author="Ioana" timestamp="20190610T232305-0400" comment="Should this be &quot;normalization to ANF&quot;?"?>CIMI-to-SOLOR<?oxy_comment_end?>
                translations, based on the QVT language used to develop the FHIR Mapping Language. </para>
            <section>
                <title>Overview</title>
                <para>QVT<footnote xml:id="__EN11__">
                        <para><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.omg.org/spec/QVT/1.2/PDF/"
                                >http://www.omg.org/spec/QVT/1.2/PDF/</link> (Accessed 9/30/2017).
                        </para>
                    </footnote> is a general model-transformation framework and language developed
                    by the Object Management Group . It includes both an imperative (“QVT-O”) and a
                    declarative (“QVT-R”) version, and offers considerable flexibility in defining
                    the constructs of purpose-specific transformation languages. Although QVT is
                    intended for the transformation of data <emphasis>models</emphasis> rather than
                    data instances, the FHIR Mapping Language shows that it can be applied to the
                    latter task as well. </para>
                <para> A number of implementations of QVT exist as open-source and commercial
                    software offerings. These include: </para>
                <itemizedlist>
                    <listitem>
                        <para>ATL (open source). Probably the most widely used and maintained of the
                            available implementations. Includes a library of existing QVT
                            transformations, to serve as examples and templates. </para>
                    </listitem>
                    <listitem>
                        <para>Eclipse M2M Project (open source). An Eclipse project that includes
                            authoring tools for QVT transformations, as well as various
                            transformation engines (including the one from ATL). </para>
                    </listitem>
                    <listitem>
                        <para>ModelMorf (proprietary)</para>
                    </listitem>
                    <listitem>
                        <para>Others (see <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://en.wikipedia.org/wiki/QVT"
                                >https://en.wikipedia.org/wiki/QVT</link>) </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Advantages and Limitations</title>
                <para> The strength of QVT is that it is very abstract, which confers great
                    flexibility and configurability to create custom transformation languages.
                    However, the abstractness also makes QVT quite difficult to understand and
                    learn, and there are limited resources to assist in the learning process. For
                    example, a search on Amazon Books for references on the QVT framework yielded
                    only 8 relevant results, most of which were not in English. In contrast, a
                    similar search for XSLT references returned 270 results. </para>
            </section>
        </section>
    </section>
</chapter>
